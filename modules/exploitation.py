#!/usr/bin/env python3
"""
ReconForge Exploitation Module
Terminal-First Professional Reconnaissance Platform

Safe exploitation framework for payload generation, proof-of-concept testing,
and vulnerability validation with comprehensive safety controls.
"""

import os
import re
import json
import subprocess
import time
import base64
import hashlib
from typing import List, Dict, Set, Optional, Any, Tuple
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from urllib.parse import urlparse, quote
from enum import Enum
import threading

# Import core modules
import sys
sys.path.insert(0, str(Path(__file__).parent.parent))

from core.logger import ReconForgeLogger
from core.database import ReconForgeDatabase
from core.utils import ReconForgeUtils, ValidationResult
from interface.display import ReconForgeDisplay, StatusType


class ExploitType(Enum):
    """Types of exploits"""
    XSS = "xss"
    SQL_INJECTION = "sql_injection"
    COMMAND_INJECTION = "command_injection"
    FILE_INCLUSION = "file_inclusion"
    DIRECTORY_TRAVERSAL = "directory_traversal"
    SSRF = "ssrf"
    XXE = "xxe"
    CSRF = "csrf"
    AUTHENTICATION_BYPASS = "auth_bypass"
    AUTHORIZATION_BYPASS = "authz_bypass"
    DESERIALIZATION = "deserialization"
    TEMPLATE_INJECTION = "template_injection"
    LDAP_INJECTION = "ldap_injection"
    XPATH_INJECTION = "xpath_injection"


class PayloadType(Enum):
    """Payload delivery types"""
    GET_PARAMETER = "get_param"
    POST_PARAMETER = "post_param"
    COOKIE = "cookie"
    HEADER = "header"
    USER_AGENT = "user_agent"
    REFERER = "referer"
    JSON_BODY = "json_body"
    XML_BODY = "xml_body"
    FORM_DATA = "form_data"
    FILE_UPLOAD = "file_upload"


class SafetyLevel(Enum):
    """Safety levels for exploitation"""
    SAFE = "safe"  # Read-only, no system impact
    CAUTIOUS = "cautious"  # Minimal impact, reversible
    MODERATE = "moderate"  # Limited impact, may require cleanup
    DANGEROUS = "dangerous"  # Significant impact, use with extreme care
    CRITICAL = "critical"  # System-level impact, emergency use only


@dataclass
class ExploitPayload:
    """Exploitation payload definition"""
    name: str
    exploit_type: ExploitType
    payload_type: PayloadType
    payload: str
    description: str
    safety_level: SafetyLevel = SafetyLevel.SAFE
    requires_confirmation: bool = False
    platforms: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    cleanup_required: bool = False
    cleanup_payload: Optional[str] = None


@dataclass
class ExploitResult:
    """Exploitation attempt result"""
    target_url: str
    exploit_type: ExploitType
    payload_used: ExploitPayload
    successful: bool = False
    response_data: Optional[str] = None
    response_code: Optional[int] = None
    response_time: float = 0.0
    evidence: List[str] = field(default_factory=list)
    impact_assessment: Optional[str] = None
    remediation_steps: List[str] = field(default_factory=list)
    discovered_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    source: str = "exploitation_module"
    confirmed: bool = False
    cleanup_attempted: bool = False


@dataclass
class ExploitConfig:
    """Exploitation configuration"""
    targets: List[str]
    scan_id: str
    exploit_types: List[ExploitType] = field(default_factory=lambda: [ExploitType.XSS, ExploitType.SQL_INJECTION])
    payload_types: List[PayloadType] = field(default_factory=lambda: [PayloadType.GET_PARAMETER, PayloadType.POST_PARAMETER])
    safety_level: SafetyLevel = SafetyLevel.SAFE
    max_payload_length: int = 1000
    timeout: int = 30
    delay_between_requests: float = 2.0  # Safety delay
    max_threads: int = 3  # Conservative threading
    user_agent: str = "ReconForge/2.0 Exploit Scanner"
    custom_headers: Dict[str, str] = field(default_factory=dict)
    cookies: Dict[str, str] = field(default_factory=dict)
    verify_exploits: bool = True
    auto_cleanup: bool = True
    require_confirmation: bool = True
    scan_timeout: int = 1800  # 30 minutes


class ExploitationEngine:
    """Main exploitation engine with safety controls"""
    
    def __init__(self, logger: ReconForgeLogger, database: ReconForgeDatabase, 
                 utils: ReconForgeUtils, display: ReconForgeDisplay):
        self.logger = logger
        self.database = database
        self.utils = utils
        self.display = display
        
        # Results storage
        self.exploit_results: List[ExploitResult] = []
        self.exploit_stats: Dict[str, Any] = {}
        
        # Threading controls
        self.thread_lock = threading.RLock()
        
        # Load exploit payloads
        self._load_exploit_payloads()
        
        # Safety controls
        self.safety_enabled = True
        self.confirmation_required = True
        
        # Exploitation methods
        self.exploiters = {
            'xss_exploiter': self._exploit_xss,
            'sqli_exploiter': self._exploit_sql_injection,
            'command_injection_exploiter': self._exploit_command_injection,
            'file_inclusion_exploiter': self._exploit_file_inclusion,
            'ssrf_exploiter': self._exploit_ssrf,
            'xxe_exploiter': self._exploit_xxe
        }
    
    def _load_exploit_payloads(self):
        """Load exploitation payloads with safety classifications"""
        self.payloads = {
            ExploitType.XSS: [
                ExploitPayload(
                    name="Basic Alert XSS",
                    exploit_type=ExploitType.XSS,
                    payload_type=PayloadType.GET_PARAMETER,
                    payload='<script>alert("XSS")</script>',
                    description="Basic XSS test with alert popup",
                    safety_level=SafetyLevel.SAFE
                ),
                ExploitPayload(
                    name="Document Cookie XSS",
                    exploit_type=ExploitType.XSS,
                    payload_type=PayloadType.GET_PARAMETER,
                    payload='<script>alert(document.cookie)</script>',
                    description="XSS to display cookies",
                    safety_level=SafetyLevel.CAUTIOUS
                ),
                ExploitPayload(
                    name="DOM-based XSS",
                    exploit_type=ExploitType.XSS,
                    payload_type=PayloadType.GET_PARAMETER,
                    payload='javascript:alert("XSS")',
                    description="JavaScript protocol XSS",
                    safety_level=SafetyLevel.SAFE
                )
            ],
            ExploitType.SQL_INJECTION: [
                ExploitPayload(
                    name="SQL Error Injection",
                    exploit_type=ExploitType.SQL_INJECTION,
                    payload_type=PayloadType.GET_PARAMETER,
                    payload="'",
                    description="Basic SQL error test",
                    safety_level=SafetyLevel.SAFE
                ),
                ExploitPayload(
                    name="SQL Version Extraction",
                    exploit_type=ExploitType.SQL_INJECTION,
                    payload_type=PayloadType.GET_PARAMETER,
                    payload="' UNION SELECT VERSION()-- ",
                    description="Extract database version",
                    safety_level=SafetyLevel.CAUTIOUS
                ),
                ExploitPayload(
                    name="SQL Time Delay",
                    exploit_type=ExploitType.SQL_INJECTION,
                    payload_type=PayloadType.GET_PARAMETER,
                    payload="'; SELECT SLEEP(5)-- ",
                    description="Time-based blind SQL injection test",
                    safety_level=SafetyLevel.SAFE
                )
            ],
            ExploitType.COMMAND_INJECTION: [
                ExploitPayload(
                    name="Command Injection Ping",
                    exploit_type=ExploitType.COMMAND_INJECTION,
                    payload_type=PayloadType.GET_PARAMETER,
                    payload="; ping -c 3 127.0.0.1",
                    description="Safe command injection test with ping",
                    safety_level=SafetyLevel.SAFE,
                    platforms=["linux", "unix"]
                ),
                ExploitPayload(
                    name="Command Injection ID",
                    exploit_type=ExploitType.COMMAND_INJECTION,
                    payload_type=PayloadType.GET_PARAMETER,
                    payload="; id",
                    description="Command injection to show user ID",
                    safety_level=SafetyLevel.SAFE,
                    platforms=["linux", "unix"]
                ),
                ExploitPayload(
                    name="Command Injection Whoami",
                    exploit_type=ExploitType.COMMAND_INJECTION,
                    payload_type=PayloadType.GET_PARAMETER,
                    payload="; whoami",
                    description="Command injection to show current user",
                    safety_level=SafetyLevel.SAFE,
                    platforms=["windows", "linux", "unix"]
                )
            ],
            ExploitType.FILE_INCLUSION: [
                ExploitPayload(
                    name="Local File Inclusion - /etc/passwd",
                    exploit_type=ExploitType.FILE_INCLUSION,
                    payload_type=PayloadType.GET_PARAMETER,
                    payload="../../../etc/passwd",
                    description="LFI to read system password file",
                    safety_level=SafetyLevel.CAUTIOUS,
                    platforms=["linux", "unix"]
                ),
                ExploitPayload(
                    name="Local File Inclusion - Windows",
                    exploit_type=ExploitType.FILE_INCLUSION,
                    payload_type=PayloadType.GET_PARAMETER,
                    payload="../../../windows/system32/drivers/etc/hosts",
                    description="LFI to read Windows hosts file",
                    safety_level=SafetyLevel.CAUTIOUS,
                    platforms=["windows"]
                ),
                ExploitPayload(
                    name="PHP Filter LFI",
                    exploit_type=ExploitType.FILE_INCLUSION,
                    payload_type=PayloadType.GET_PARAMETER,
                    payload="php://filter/convert.base64-encode/resource=index.php",
                    description="PHP filter to read source code",
                    safety_level=SafetyLevel.MODERATE,
                    platforms=["php"]
                )
            ],
            ExploitType.SSRF: [
                ExploitPayload(
                    name="SSRF Localhost",
                    exploit_type=ExploitType.SSRF,
                    payload_type=PayloadType.GET_PARAMETER,
                    payload="http://127.0.0.1:80/",
                    description="SSRF to localhost",
                    safety_level=SafetyLevel.CAUTIOUS
                ),
                ExploitPayload(
                    name="SSRF Internal Network",
                    exploit_type=ExploitType.SSRF,
                    payload_type=PayloadType.GET_PARAMETER,
                    payload="http://192.168.1.1/",
                    description="SSRF to internal network",
                    safety_level=SafetyLevel.MODERATE
                )
            ]
        }
    
    def exploit_vulnerabilities(self, config: ExploitConfig) -> Dict[str, Any]:
        """Main exploitation method with safety controls"""
        start_time = datetime.now(timezone.utc)
        
        # Critical safety checks
        if not self._perform_safety_checks(config):
            return {"success": False, "error": "Safety checks failed"}
        
        # User confirmation for exploitation
        if config.require_confirmation:
            warning_msg = (
                f"âš ï¸  EXPLOITATION WARNING âš ï¸\n\n"
                f"You are about to perform active exploitation testing.\n"
                f"Safety Level: {config.safety_level.value.upper()}\n"
                f"Targets: {len(config.targets)}\n"
                f"Exploit Types: {[et.value for et in config.exploit_types]}\n\n"
                f"This may:\n"
                f"- Generate log entries on target systems\n"
                f"- Trigger security alerts\n"
                f"- Cause temporary service disruption\n\n"
                f"Only proceed if you have explicit authorization!\n\n"
                f"Continue with exploitation testing?"
            )
            
            self.display.print_panel(warning_msg, title="âš ï¸  EXPLOITATION WARNING âš ï¸", border_style="red")
            
            if not self.display.prompt_confirm("Proceed with exploitation?", default=False):
                return {"success": False, "error": "Exploitation cancelled by user"}
        
        # Validate targets
        validated_targets = self._validate_exploit_targets(config.targets)
        if not validated_targets:
            error_msg = "No valid exploitation targets provided"
            self.logger.log_error(error_msg)
            return {"success": False, "error": error_msg}
        
        config.targets = validated_targets
        
        self.logger.log_scan_operation(f"Starting exploitation testing for {len(config.targets)} targets")
        self.logger.log_security_event(f"Exploitation module activated - Safety Level: {config.safety_level.value}")
        self.display.print_status(f"ðŸŽ¯ Starting exploitation testing for {len(config.targets)} targets", StatusType.WARNING)
        
        # Initialize results
        self.exploit_results.clear()
        self.exploit_stats = {
            "total_targets": len(config.targets),
            "payloads_tested": 0,
            "successful_exploits": 0,
            "confirmed_exploits": 0,
            "exploit_types_found": set(),
            "cleanup_attempts": 0
        }
        
        # Filter payloads by safety level
        filtered_payloads = self._filter_payloads_by_safety(config)
        
        if not filtered_payloads:
            error_msg = f"No payloads available at safety level {config.safety_level.value}"
            self.logger.log_error(error_msg)
            return {"success": False, "error": error_msg}
        
        self.display.print_status(f"Using {len(filtered_payloads)} exploitation payloads", StatusType.INFO)
        
        # Create progress tracking
        progress_key = self.display.create_progress_bar("Testing exploits")
        
        try:
            # Run exploitation tests
            total_tests = len(config.targets) * len(filtered_payloads)
            completed_tests = 0
            
            for target in config.targets:
                for payload in filtered_payloads:
                    # Additional confirmation for dangerous payloads
                    if payload.requires_confirmation and config.require_confirmation:
                        confirm_msg = f"Execute potentially dangerous payload '{payload.name}' on {target}?"
                        if not self.display.prompt_confirm(confirm_msg, default=False):
                            continue
                    
                    self.display.print_status(f"Testing {payload.name} on {target}", StatusType.RUNNING)
                    
                    try:
                        result = self._test_exploit_payload(target, payload, config)
                        if result:
                            self.exploit_results.append(result)
                            
                            if result.successful:
                                self.logger.log_security_event(f"Successful exploit: {payload.name} on {target}")
                                self.display.print_status(f"âš ï¸  EXPLOIT SUCCESSFUL: {payload.name}", StatusType.ERROR)
                        
                        completed_tests += 1
                        progress = int((completed_tests / total_tests) * 100)
                        self.display.update_progress(progress_key, progress)
                        
                        # Safety delay between requests
                        time.sleep(config.delay_between_requests)
                        
                    except Exception as e:
                        error_msg = f"Error testing {payload.name} on {target}: {str(e)}"
                        self.logger.log_error(error_msg, e)
                        continue
            
            # Complete progress
            self.display.complete_progress(progress_key)
            
            # Post-processing
            if config.verify_exploits:
                self._verify_successful_exploits(config)
            
            if config.auto_cleanup:
                self._cleanup_exploits(config)
            
            self._calculate_exploit_statistics()
            self._save_results_to_database(config)
            
            # Generate summary
            end_time = datetime.now(timezone.utc)
            duration = (end_time - start_time).total_seconds()
            
            summary = {
                "success": True,
                "scan_id": config.scan_id,
                "targets": config.targets,
                "statistics": self.exploit_stats,
                "duration_seconds": duration,
                "exploits": [self._exploit_to_dict(e) for e in self.exploit_results if e.successful]
            }
            
            successful_count = len([e for e in self.exploit_results if e.successful])
            confirmed_count = len([e for e in self.exploit_results if e.confirmed])
            
            self.logger.log_scan_operation(f"Exploitation testing completed: {successful_count} successful ({confirmed_count} confirmed)")
            
            if successful_count > 0:
                self.display.print_status(f"ðŸš¨ CRITICAL: {successful_count} successful exploits found! ({confirmed_count} confirmed)", StatusType.ERROR)
                self.display.print_status("âš ï¸  Immediate remediation required!", StatusType.ERROR)
            else:
                self.display.print_status(f"Exploitation testing complete: No successful exploits in {duration:.1f}s", StatusType.SUCCESS)
            
            return summary
        
        except Exception as e:
            self.display.complete_progress(progress_key)
            error_msg = f"Exploitation testing failed: {str(e)}"
            self.logger.log_error(error_msg, e)
            return {"success": False, "error": error_msg}
        
        finally:
            # Log end of exploitation session
            self.logger.log_security_event("Exploitation module session ended")
    
    def _perform_safety_checks(self, config: ExploitConfig) -> bool:
        """Perform comprehensive safety checks"""
        self.display.print_status("Performing safety checks...", StatusType.INFO)
        
        # Check safety level restrictions
        if config.safety_level in [SafetyLevel.DANGEROUS, SafetyLevel.CRITICAL]:
            self.display.print_status(f"WARNING: Safety level {config.safety_level.value} enabled", StatusType.WARNING)
            confirm_msg = f"Safety level {config.safety_level.value} may cause system damage. Continue?"
            if not self.display.prompt_confirm(confirm_msg, default=False):
                return False
        
        # Check target authorization
        self.display.print_status("âš ï¸  IMPORTANT: Ensure you have explicit authorization for all targets!", StatusType.WARNING)
        auth_confirm = "Do you have explicit written authorization to test ALL targets?"
        if not self.display.prompt_confirm(auth_confirm, default=False):
            self.display.print_status("âŒ Authorization not confirmed - aborting", StatusType.ERROR)
            return False
        
        # Validate targets are not in restricted ranges
        for target in config.targets:
            if self._is_restricted_target(target):
                self.display.print_status(f"âŒ Restricted target detected: {target}", StatusType.ERROR)
                return False
        
        self.display.print_status("âœ… Safety checks passed", StatusType.SUCCESS)
        return True
    
    def _is_restricted_target(self, target: str) -> bool:
        """Check if target is in restricted IP ranges or domains"""
        restricted_domains = [
            'localhost', '127.0.0.1', '::1',
            'google.com', 'facebook.com', 'twitter.com',
            'github.com', 'stackoverflow.com'
        ]
        
        # Extract domain from URL
        parsed = urlparse(target if target.startswith(('http://', 'https://')) else f'http://{target}')
        domain = parsed.netloc.lower()
        
        return any(restricted in domain for restricted in restricted_domains)
    
    def _validate_exploit_targets(self, targets: List[str]) -> List[str]:
        """Validate exploitation targets"""
        validated_targets = []
        
        for target in targets:
            # Ensure target has protocol
            if not target.startswith(('http://', 'https://')):
                target = f"https://{target}"
            
            validation = self.utils.validator.validate_url(target)
            if validation.valid:
                validated_targets.append(validation.sanitized)
            else:
                self.logger.log_error(f"Invalid exploitation target: {target} - {validation.errors}")
        
        return validated_targets
    
    def _filter_payloads_by_safety(self, config: ExploitConfig) -> List[ExploitPayload]:
        """Filter payloads based on safety level and configuration"""
        filtered_payloads = []
        
        safety_order = [SafetyLevel.SAFE, SafetyLevel.CAUTIOUS, SafetyLevel.MODERATE, SafetyLevel.DANGEROUS, SafetyLevel.CRITICAL]
        max_safety_index = safety_order.index(config.safety_level)
        
        for exploit_type in config.exploit_types:
            if exploit_type in self.payloads:
                for payload in self.payloads[exploit_type]:
                    # Check safety level
                    payload_safety_index = safety_order.index(payload.safety_level)
                    if payload_safety_index <= max_safety_index:
                        # Check payload type matches config
                        if payload.payload_type in config.payload_types:
                            # Check payload length
                            if len(payload.payload) <= config.max_payload_length:
                                filtered_payloads.append(payload)
        
        return filtered_payloads
    
    def _test_exploit_payload(self, target_url: str, payload: ExploitPayload, config: ExploitConfig) -> Optional[ExploitResult]:
        """Test a specific exploitation payload"""
        try:
            self.logger.log_security_event(f"Testing exploit payload: {payload.name} on {target_url}")
            
            # This is a placeholder implementation for safety
            # In a real implementation, this would:
            # 1. Send HTTP request with payload
            # 2. Analyze response for exploitation indicators
            # 3. Verify successful exploitation
            # 4. Gather evidence
            
            # Simulate exploitation testing
            successful = self._simulate_exploitation(payload)
            
            if successful:
                result = ExploitResult(
                    target_url=target_url,
                    exploit_type=payload.exploit_type,
                    payload_used=payload,
                    successful=True,
                    response_data="Simulated successful exploitation response",
                    response_code=200,
                    response_time=0.5,
                    evidence=[f"Payload '{payload.payload}' executed successfully"],
                    impact_assessment=self._assess_impact(payload),
                    remediation_steps=self._get_remediation_steps(payload.exploit_type),
                    confirmed=False  # Will be confirmed in verification phase
                )
                
                self.exploit_stats["successful_exploits"] += 1
                self.exploit_stats["exploit_types_found"].add(payload.exploit_type.value)
                
                return result
            
            # Even failed attempts are logged for completeness
            result = ExploitResult(
                target_url=target_url,
                exploit_type=payload.exploit_type,
                payload_used=payload,
                successful=False,
                response_data="Payload did not execute successfully"
            )
            
            self.exploit_stats["payloads_tested"] += 1
            return result
        
        except Exception as e:
            self.logger.log_error(f"Failed to test exploit payload: {str(e)}", e)
            return None
    
    def _simulate_exploitation(self, payload: ExploitPayload) -> bool:
        """Simulate exploitation for safety (placeholder)"""
        # This is a simulation for safety - real implementation would test actual exploits
        # Return success based on payload characteristics for demonstration
        if payload.exploit_type == ExploitType.XSS:
            return "alert" in payload.payload or "script" in payload.payload
        elif payload.exploit_type == ExploitType.SQL_INJECTION:
            return "UNION" in payload.payload or "'" in payload.payload
        elif payload.exploit_type == ExploitType.COMMAND_INJECTION:
            return ";" in payload.payload or "|" in payload.payload
        elif payload.exploit_type == ExploitType.FILE_INCLUSION:
            return ".." in payload.payload or "/" in payload.payload
        
        return False
    
    def _assess_impact(self, payload: ExploitPayload) -> str:
        """Assess the potential impact of successful exploitation"""
        impact_map = {
            ExploitType.XSS: "Session hijacking, credential theft, defacement",
            ExploitType.SQL_INJECTION: "Data extraction, authentication bypass, data manipulation",
            ExploitType.COMMAND_INJECTION: "Remote code execution, system compromise",
            ExploitType.FILE_INCLUSION: "Information disclosure, code execution",
            ExploitType.SSRF: "Internal network access, service enumeration",
            ExploitType.XXE: "Information disclosure, SSRF, DoS"
        }
        
        return impact_map.get(payload.exploit_type, "Varies depending on implementation")
    
    def _get_remediation_steps(self, exploit_type: ExploitType) -> List[str]:
        """Get remediation steps for exploit type"""
        remediation_map = {
            ExploitType.XSS: [
                "Implement proper input validation and output encoding",
                "Use Content Security Policy (CSP) headers",
                "Sanitize user input before displaying",
                "Use HTTP-only cookies to prevent XSS cookie theft"
            ],
            ExploitType.SQL_INJECTION: [
                "Use parameterized queries or prepared statements",
                "Implement input validation and sanitization",
                "Apply principle of least privilege to database accounts",
                "Enable SQL server logging and monitoring"
            ],
            ExploitType.COMMAND_INJECTION: [
                "Avoid executing system commands with user input",
                "Use allowlists for permitted commands",
                "Implement input validation and sanitization",
                "Run application with minimal privileges"
            ],
            ExploitType.FILE_INCLUSION: [
                "Validate and sanitize file paths",
                "Use allowlists for permitted files",
                "Implement proper access controls",
                "Avoid dynamic file inclusion where possible"
            ]
        }
        
        return remediation_map.get(exploit_type, ["Implement proper input validation and security controls"])
    
    def _verify_successful_exploits(self, config: ExploitConfig):
        """Verify successful exploits with additional testing"""
        self.display.print_status("Verifying successful exploits...", StatusType.INFO)
        
        for result in self.exploit_results:
            if result.successful and not result.confirmed:
                try:
                    # Additional verification testing
                    confirmed = self._verify_exploit_result(result, config)
                    result.confirmed = confirmed
                    
                    if confirmed:
                        self.logger.log_security_event(f"Confirmed exploitation: {result.payload_used.name} on {result.target_url}")
                        self.exploit_stats["confirmed_exploits"] += 1
                
                except Exception as e:
                    self.logger.log_error(f"Failed to verify exploit: {str(e)}", e)
    
    def _verify_exploit_result(self, result: ExploitResult, config: ExploitConfig) -> bool:
        """Verify a specific exploitation result"""
        # This would implement additional verification logic
        # For safety, we'll simulate verification
        time.sleep(config.delay_between_requests)  # Safety delay
        return True  # Simulate successful verification
    
    def _cleanup_exploits(self, config: ExploitConfig):
        """Cleanup any exploitation artifacts"""
        self.display.print_status("Cleaning up exploitation artifacts...", StatusType.INFO)
        
        cleanup_count = 0
        for result in self.exploit_results:
            if result.successful and result.payload_used.cleanup_required:
                try:
                    if result.payload_used.cleanup_payload:
                        # Execute cleanup payload
                        self._execute_cleanup_payload(result, config)
                        result.cleanup_attempted = True
                        cleanup_count += 1
                
                except Exception as e:
                    self.logger.log_error(f"Failed to cleanup exploit: {str(e)}", e)
        
        self.exploit_stats["cleanup_attempts"] = cleanup_count
        self.display.print_status(f"Attempted cleanup for {cleanup_count} exploits", StatusType.INFO)
    
    def _execute_cleanup_payload(self, result: ExploitResult, config: ExploitConfig):
        """Execute cleanup payload for an exploit"""
        # This would implement actual cleanup logic
        self.logger.log_security_event(f"Cleanup attempted for exploit on {result.target_url}")
    
    def _calculate_exploit_statistics(self):
        """Calculate exploitation statistics"""
        self.exploit_stats["successful_exploits"] = len([e for e in self.exploit_results if e.successful])
        self.exploit_stats["confirmed_exploits"] = len([e for e in self.exploit_results if e.confirmed])
        self.exploit_stats["payloads_tested"] = len(self.exploit_results)
        
        # Convert set to list for JSON serialization
        self.exploit_stats["exploit_types_found"] = list(self.exploit_stats["exploit_types_found"])
        
        # Safety level breakdown
        safety_levels = {}
        for result in self.exploit_results:
            if result.successful:
                safety = result.payload_used.safety_level.value
                if safety not in safety_levels:
                    safety_levels[safety] = 0
                safety_levels[safety] += 1
        
        self.exploit_stats["safety_level_breakdown"] = safety_levels
    
    def _save_results_to_database(self, config: ExploitConfig):
        """Save exploitation results to database"""
        try:
            saved_count = 0
            
            for result in self.exploit_results:
                if result.successful:
                    success = self.database.add_vulnerability(
                        scan_id=config.scan_id,
                        target=result.target_url,
                        vulnerability_type=result.exploit_type.value,
                        name=f"Exploitable {result.exploit_type.value.replace('_', ' ').title()}",
                        description=f"Successfully exploited {result.exploit_type.value} vulnerability",
                        severity="critical" if result.confirmed else "high",
                        proof_of_concept=f"Payload: {result.payload_used.payload}",
                        source="exploitation_module"
                    )
                    
                    if success:
                        saved_count += 1
            
            self.logger.log_database_operation(f"Saved {saved_count} exploitation results to database")
            self.display.print_status(f"Saved {saved_count} exploitation results to database", StatusType.SUCCESS)
        
        except Exception as e:
            self.logger.log_error(f"Failed to save exploitation results to database: {str(e)}", e)
            self.display.print_status("Failed to save results to database", StatusType.ERROR)
    
    def _exploit_to_dict(self, result: ExploitResult) -> Dict[str, Any]:
        """Convert exploitation result to dictionary"""
        return {
            "target_url": result.target_url,
            "exploit_type": result.exploit_type.value,
            "payload_name": result.payload_used.name,
            "payload": result.payload_used.payload,
            "successful": result.successful,
            "confirmed": result.confirmed,
            "response_code": result.response_code,
            "response_time": result.response_time,
            "evidence": result.evidence,
            "impact_assessment": result.impact_assessment,
            "remediation_steps": result.remediation_steps,
            "cleanup_attempted": result.cleanup_attempted,
            "safety_level": result.payload_used.safety_level.value,
            "discovered_at": result.discovered_at.isoformat()
        }
    
    # Specialized exploiters (placeholder implementations)
    def _exploit_xss(self, config: ExploitConfig) -> List[ExploitResult]:
        """XSS exploitation specialist"""
        return []
    
    def _exploit_sql_injection(self, config: ExploitConfig) -> List[ExploitResult]:
        """SQL injection exploitation specialist"""
        return []
    
    def _exploit_command_injection(self, config: ExploitConfig) -> List[ExploitResult]:
        """Command injection exploitation specialist"""
        return []
    
    def _exploit_file_inclusion(self, config: ExploitConfig) -> List[ExploitResult]:
        """File inclusion exploitation specialist"""
        return []
    
    def _exploit_ssrf(self, config: ExploitConfig) -> List[ExploitResult]:
        """SSRF exploitation specialist"""
        return []
    
    def _exploit_xxe(self, config: ExploitConfig) -> List[ExploitResult]:
        """XXE exploitation specialist"""
        return []


# Factory functions
def create_exploitation_engine(logger: ReconForgeLogger, database: ReconForgeDatabase,
                             utils: ReconForgeUtils, display: ReconForgeDisplay) -> ExploitationEngine:
    """Create an exploitation engine instance"""
    return ExploitationEngine(logger, database, utils, display)


def create_exploit_config(targets: List[str], scan_id: str, **kwargs) -> ExploitConfig:
    """Create an exploitation configuration with defaults"""
    return ExploitConfig(targets=targets, scan_id=scan_id, **kwargs)