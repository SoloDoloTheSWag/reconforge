#!/usr/bin/env python3
"""
ReconForge Vulnerability Scanning Module
Terminal-First Professional Reconnaissance Platform

Comprehensive vulnerability assessment using multiple security scanners including
Nuclei, custom scanners, and specialized vulnerability detection tools.
"""

import os
import re
import json
import time
import subprocess
from typing import List, Dict, Set, Optional, Any, Tuple
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from urllib.parse import urlparse
import concurrent.futures
from enum import Enum

# Import core modules
import sys
sys.path.insert(0, str(Path(__file__).parent.parent))

from core.logger import ReconForgeLogger
from core.database import ReconForgeDatabase
from core.utils import ReconForgeUtils, ValidationResult
from interface.display import ReconForgeDisplay, StatusType


class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnCategory(Enum):
    """Vulnerability categories"""
    XSS = "xss"
    SQL_INJECTION = "sqli"
    RCE = "rce"
    LFI_RFI = "lfi_rfi"
    SSRF = "ssrf"
    XXE = "xxe"
    CSRF = "csrf"
    AUTHENTICATION = "auth"
    AUTHORIZATION = "authz"
    INFORMATION_DISCLOSURE = "info_disclosure"
    MISCONFIG = "misconfiguration"
    SSL_TLS = "ssl_tls"
    DNS = "dns"
    SUBDOMAIN_TAKEOVER = "subdomain_takeover"
    GENERIC = "generic"


@dataclass
class VulnerabilityResult:
    """Vulnerability scanning result"""
    target: str
    vulnerability_id: str
    name: str
    description: str
    severity: SeverityLevel
    category: VulnCategory
    source: str
    template_id: Optional[str] = None
    cvss_score: Optional[float] = None
    cve_id: Optional[str] = None
    cwe_id: Optional[str] = None
    reference_urls: List[str] = field(default_factory=list)
    proof_of_concept: Optional[str] = None
    request_data: Optional[str] = None
    response_data: Optional[str] = None
    discovered_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    false_positive: bool = False
    verified: bool = False


@dataclass
class ScanConfig:
    """Configuration for vulnerability scanning"""
    targets: List[str]
    scan_id: str
    scan_type: str = "comprehensive"  # comprehensive, quick, custom
    severity_filter: List[SeverityLevel] = field(default_factory=lambda: list(SeverityLevel))
    categories: List[VulnCategory] = field(default_factory=list)
    timeout: int = 1800  # 30 minutes default
    max_threads: int = 10
    rate_limit: int = 100  # requests per second
    follow_redirects: bool = True
    verify_ssl: bool = False
    custom_headers: Dict[str, str] = field(default_factory=dict)
    exclude_paths: List[str] = field(default_factory=list)
    include_paths: List[str] = field(default_factory=list)
    nuclei_templates: List[str] = field(default_factory=list)
    passive_only: bool = False
    active_scanning: bool = True


class VulnerabilityScanner:
    """Main vulnerability scanning engine"""
    
    def __init__(self, logger: ReconForgeLogger, database: ReconForgeDatabase, 
                 utils: ReconForgeUtils, display: ReconForgeDisplay):
        self.logger = logger
        self.database = database
        self.utils = utils
        self.display = display
        
        # Results storage
        self.vulnerabilities: List[VulnerabilityResult] = []
        self.scan_stats: Dict[str, Any] = {}
        
        # Scanner configurations
        self.scanners = {
            'nuclei': self._scan_nuclei,
            'subzy': self._scan_subdomain_takeover,
            'ssl_scanner': self._scan_ssl_tls,
            'dns_scanner': self._scan_dns_security,
            'header_scanner': self._scan_security_headers,
            'directory_scanner': self._scan_directory_traversal,
            'custom_xss': self._scan_custom_xss,
            'custom_sqli': self._scan_custom_sqli,
            'custom_rce': self._scan_custom_rce,
            'misconfig_scanner': self._scan_misconfigurations
        }
        
        # Tool availability check
        self._check_tool_availability()
        
        # Load vulnerability templates/signatures
        self._load_vulnerability_templates()
    
    def _check_tool_availability(self):
        """Check which scanning tools are available"""
        required_tools = ['nuclei', 'subzy', 'httpx', 'nmap', 'gobuster', 'ffuf', 'sqlmap']
        
        self.available_tools = {}
        for tool in required_tools:
            self.available_tools[tool] = self.utils.tool_manager.is_tool_available(tool)
        
        available_count = sum(self.available_tools.values())
        self.logger.log_system(f"Vulnerability scanning tools available: {available_count}/{len(required_tools)}")
    
    def _load_vulnerability_templates(self):
        """Load custom vulnerability detection templates"""
        self.custom_templates = {
            'xss_payloads': [
                '<script>alert("XSS")</script>',
                '"><script>alert("XSS")</script>',
                "';alert('XSS');//",
                'javascript:alert("XSS")',
                '<img src=x onerror=alert("XSS")>'
            ],
            'sqli_payloads': [
                "' OR '1'='1",
                "' UNION SELECT NULL--",
                "'; DROP TABLE users--",
                "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
                "' OR SLEEP(5)--"
            ],
            'rce_payloads': [
                '; ls -la',
                '| whoami',
                '`id`',
                '$(whoami)',
                '; cat /etc/passwd',
                '| ping -c 4 127.0.0.1'
            ],
            'lfi_payloads': [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                '/etc/passwd',
                'C:\\windows\\system32\\drivers\\etc\\hosts',
                'php://filter/convert.base64-encode/resource=index.php'
            ]
        }
    
    def scan_vulnerabilities(self, config: ScanConfig) -> Dict[str, Any]:
        """Main vulnerability scanning method"""
        start_time = datetime.now(timezone.utc)
        
        # Validate targets
        validated_targets = []
        for target in config.targets:
            if target.startswith(('http://', 'https://')):
                validation = self.utils.validator.validate_url(target)
            else:
                validation = self.utils.validator.validate_domain(target)
            
            if validation.valid:
                validated_targets.append(validation.sanitized)
            else:
                self.logger.log_error(f"Invalid target: {target} - {validation.errors}")
        
        if not validated_targets:
            error_msg = "No valid targets provided"
            self.logger.log_error(error_msg)
            return {"success": False, "error": error_msg}
        
        config.targets = validated_targets
        
        self.logger.log_scan_operation(f"Starting vulnerability scan for {len(config.targets)} targets")
        self.display.print_status(f"Starting vulnerability scan for {len(config.targets)} targets", StatusType.INFO)
        
        # Initialize results
        self.vulnerabilities.clear()
        self.scan_stats = {
            "total_targets": len(config.targets),
            "scanners_used": [],
            "vulnerabilities_found": 0,
            "severity_counts": {sev.value: 0 for sev in SeverityLevel},
            "category_counts": {cat.value: 0 for cat in VulnCategory}
        }
        
        # Determine scanners to use
        scanners_to_run = self._determine_scanners(config)
        
        if not scanners_to_run:
            error_msg = "No vulnerability scanners available or enabled"
            self.logger.log_error(error_msg)
            return {"success": False, "error": error_msg}
        
        self.display.print_status(f"Using {len(scanners_to_run)} vulnerability scanners", StatusType.INFO)
        
        # Create progress tracking
        progress_key = self.display.create_progress_bar("Scanning for vulnerabilities")
        
        try:
            # Run vulnerability scanners
            total_scanners = len(scanners_to_run)
            completed_scanners = 0
            
            for scanner_name, scanner_func in scanners_to_run.items():
                self.display.print_status(f"Running {scanner_name} scanner...", StatusType.RUNNING)
                
                try:
                    scanner_results = scanner_func(config)
                    self._process_scanner_results(scanner_name, scanner_results)
                    
                    completed_scanners += 1
                    progress = int((completed_scanners / total_scanners) * 100)
                    self.display.update_progress(progress_key, progress)
                    
                    vuln_count = len(scanner_results)
                    self.display.print_status(f"Completed {scanner_name}: {vuln_count} vulnerabilities", StatusType.SUCCESS)
                    
                except Exception as e:
                    error_msg = f"Error in {scanner_name}: {str(e)}"
                    self.logger.log_error(error_msg, e)
                    self.display.print_status(error_msg, StatusType.ERROR)
                    continue
            
            # Complete progress
            self.display.complete_progress(progress_key)
            
            # Post-processing
            self._deduplicate_vulnerabilities()
            self._calculate_risk_scores()
            self._save_results_to_database(config)
            
            # Generate summary
            end_time = datetime.now(timezone.utc)
            duration = (end_time - start_time).total_seconds()
            
            self.scan_stats["vulnerabilities_found"] = len(self.vulnerabilities)
            self.scan_stats["duration_seconds"] = duration
            
            # Count by severity and category
            for vuln in self.vulnerabilities:
                self.scan_stats["severity_counts"][vuln.severity.value] += 1
                self.scan_stats["category_counts"][vuln.category.value] += 1
            
            summary = {
                "success": True,
                "scan_id": config.scan_id,
                "targets": config.targets,
                "statistics": self.scan_stats,
                "vulnerabilities": [self._vulnerability_to_dict(v) for v in self.vulnerabilities]
            }
            
            self.logger.log_scan_operation(f"Vulnerability scan completed: {len(self.vulnerabilities)} vulnerabilities found")
            self.display.print_status(f"Scan complete: {len(self.vulnerabilities)} vulnerabilities found in {duration:.1f}s", StatusType.SUCCESS)
            
            return summary
        
        except Exception as e:
            self.display.complete_progress(progress_key)
            error_msg = f"Vulnerability scanning failed: {str(e)}"
            self.logger.log_error(error_msg, e)
            return {"success": False, "error": error_msg}
    
    def _determine_scanners(self, config: ScanConfig) -> Dict[str, Any]:
        """Determine which scanners to use based on configuration and availability"""
        scanners_to_run = {}
        
        # Default scanner selection based on scan type
        if config.scan_type == "comprehensive":
            selected_scanners = list(self.scanners.keys())
        elif config.scan_type == "quick":
            selected_scanners = ['nuclei', 'header_scanner', 'ssl_scanner']
        else:  # custom
            selected_scanners = list(self.scanners.keys())
        
        # Filter by availability
        for scanner_name in selected_scanners:
            if self._is_scanner_available(scanner_name):
                scanners_to_run[scanner_name] = self.scanners[scanner_name]
                self.scan_stats["scanners_used"].append(scanner_name)
            else:
                self.logger.log_system(f"Skipping {scanner_name}: dependencies not available")
        
        return scanners_to_run
    
    def _is_scanner_available(self, scanner_name: str) -> bool:
        """Check if a scanner is available based on tool dependencies"""
        tool_requirements = {
            'nuclei': ['nuclei'],
            'subzy': ['subzy'],
            'ssl_scanner': [],  # Built-in
            'dns_scanner': [],  # Built-in
            'header_scanner': ['httpx'],
            'directory_scanner': ['gobuster', 'ffuf'],
            'custom_xss': [],  # Built-in
            'custom_sqli': [],  # Built-in
            'custom_rce': [],  # Built-in
            'misconfig_scanner': []  # Built-in
        }
        
        required_tools = tool_requirements.get(scanner_name, [])
        if not required_tools:
            return True  # Built-in scanners
        
        return all(self.available_tools.get(tool, False) for tool in required_tools)
    
    def _process_scanner_results(self, scanner_name: str, results: List[VulnerabilityResult]):
        """Process results from a vulnerability scanner"""
        for vuln in results:
            vuln.source = scanner_name
            self.vulnerabilities.append(vuln)
        
        self.logger.log_scan_operation(f"{scanner_name} found {len(results)} vulnerabilities")
    
    def _deduplicate_vulnerabilities(self):
        """Remove duplicate vulnerabilities"""
        seen = set()
        unique_vulns = []
        
        for vuln in self.vulnerabilities:
            # Create a signature for deduplication
            signature = f"{vuln.target}:{vuln.vulnerability_id}:{vuln.name}"
            
            if signature not in seen:
                seen.add(signature)
                unique_vulns.append(vuln)
        
        removed_count = len(self.vulnerabilities) - len(unique_vulns)
        if removed_count > 0:
            self.logger.log_system(f"Removed {removed_count} duplicate vulnerabilities")
        
        self.vulnerabilities = unique_vulns
    
    def _calculate_risk_scores(self):
        """Calculate risk scores for vulnerabilities"""
        for vuln in self.vulnerabilities:
            # Base score from severity
            severity_scores = {
                SeverityLevel.CRITICAL: 10.0,
                SeverityLevel.HIGH: 8.0,
                SeverityLevel.MEDIUM: 5.0,
                SeverityLevel.LOW: 2.0,
                SeverityLevel.INFO: 0.0
            }
            
            base_score = severity_scores.get(vuln.severity, 0.0)
            
            # Adjust based on verification status
            if vuln.verified:
                base_score *= 1.0  # No change for verified vulns
            else:
                base_score *= 0.8  # Reduce score for unverified
            
            # Adjust based on category
            high_impact_categories = [
                VulnCategory.RCE, VulnCategory.SQL_INJECTION,
                VulnCategory.AUTHENTICATION, VulnCategory.AUTHORIZATION
            ]
            
            if vuln.category in high_impact_categories:
                base_score *= 1.2
            
            vuln.cvss_score = min(10.0, base_score)
    
    def _save_results_to_database(self, config: ScanConfig):
        """Save vulnerability results to database"""
        try:
            saved_count = 0
            
            for vuln in self.vulnerabilities:
                success = self.database.add_vulnerability(
                    scan_id=config.scan_id,
                    target=vuln.target,
                    vulnerability_type=vuln.category.value,
                    name=vuln.name,
                    description=vuln.description,
                    severity=vuln.severity.value,
                    cvss_score=vuln.cvss_score,
                    cve_id=vuln.cve_id,
                    proof_of_concept=vuln.proof_of_concept,
                    source=vuln.source
                )
                
                if success:
                    saved_count += 1
            
            self.logger.log_database_operation(f"Saved {saved_count} vulnerabilities to database")
            self.display.print_status(f"Saved {saved_count} vulnerabilities to database", StatusType.SUCCESS)
        
        except Exception as e:
            self.logger.log_error(f"Failed to save vulnerabilities to database: {str(e)}", e)
            self.display.print_status("Failed to save vulnerabilities to database", StatusType.ERROR)
    
    def _vulnerability_to_dict(self, vuln: VulnerabilityResult) -> Dict[str, Any]:
        """Convert vulnerability result to dictionary"""
        return {
            "target": vuln.target,
            "vulnerability_id": vuln.vulnerability_id,
            "name": vuln.name,
            "description": vuln.description,
            "severity": vuln.severity.value,
            "category": vuln.category.value,
            "source": vuln.source,
            "cvss_score": vuln.cvss_score,
            "cve_id": vuln.cve_id,
            "verified": vuln.verified,
            "discovered_at": vuln.discovered_at.isoformat()
        }
    
    # Scanner Implementations
    def _scan_nuclei(self, config: ScanConfig) -> List[VulnerabilityResult]:
        """Nuclei vulnerability scanner"""
        if not self.available_tools.get('nuclei', False):
            return []
        
        vulnerabilities = []
        
        try:
            # Prepare target list
            target_file = Path(f"/tmp/nuclei_targets_{config.scan_id}.txt")
            with open(target_file, 'w') as f:
                for target in config.targets:
                    f.write(f"{target}\n")
            
            # Build nuclei command
            cmd = [
                'nuclei',
                '-l', str(target_file),
                '-json',
                '-silent',
                '-timeout', '10',
                '-retries', '2',
                '-rate-limit', str(config.rate_limit)
            ]
            
            # Add template filters
            if config.nuclei_templates:
                cmd.extend(['-t', ','.join(config.nuclei_templates)])
            else:
                cmd.extend(['-t', 'vulnerabilities/', '-t', 'exposures/'])
            
            # Add severity filter
            if config.severity_filter:
                severity_list = [s.value for s in config.severity_filter]
                cmd.extend(['-severity', ','.join(severity_list)])
            
            self.logger.log_tool_execution(f"Running nuclei: {' '.join(cmd)}")
            
            # Run nuclei
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=config.timeout)
            
            if result.returncode == 0:
                for line in result.stdout.strip().split('\n'):
                    if line:
                        try:
                            vuln_data = json.loads(line)
                            vuln = self._parse_nuclei_result(vuln_data)
                            if vuln:
                                vulnerabilities.append(vuln)
                        except json.JSONDecodeError:
                            continue
            
            # Cleanup
            if target_file.exists():
                target_file.unlink()
        
        except Exception as e:
            self.logger.log_error(f"Nuclei scanning failed: {str(e)}", e)
        
        return vulnerabilities
    
    def _parse_nuclei_result(self, data: Dict[str, Any]) -> Optional[VulnerabilityResult]:
        """Parse nuclei JSON result into VulnerabilityResult"""
        try:
            template_info = data.get('info', {})
            
            # Map nuclei severity to our enum
            severity_map = {
                'critical': SeverityLevel.CRITICAL,
                'high': SeverityLevel.HIGH,
                'medium': SeverityLevel.MEDIUM,
                'low': SeverityLevel.LOW,
                'info': SeverityLevel.INFO
            }
            
            severity = severity_map.get(template_info.get('severity', 'info').lower(), SeverityLevel.INFO)
            
            # Determine category from tags
            category = self._determine_category_from_tags(template_info.get('tags', []))
            
            vuln = VulnerabilityResult(
                target=data.get('host', ''),
                vulnerability_id=data.get('template-id', ''),
                name=template_info.get('name', 'Unknown Vulnerability'),
                description=template_info.get('description', ''),
                severity=severity,
                category=category,
                source='nuclei',
                template_id=data.get('template-id'),
                cve_id=template_info.get('classification', {}).get('cve-id'),
                cwe_id=template_info.get('classification', {}).get('cwe-id'),
                reference_urls=template_info.get('reference', []),
                request_data=str(data.get('request', '')),
                response_data=str(data.get('response', '')),
                verified=True  # Nuclei results are generally reliable
            )
            
            return vuln
        
        except Exception as e:
            self.logger.log_error(f"Failed to parse nuclei result: {str(e)}", e)
            return None
    
    def _determine_category_from_tags(self, tags: List[str]) -> VulnCategory:
        """Determine vulnerability category from nuclei tags"""
        tag_mappings = {
            'xss': VulnCategory.XSS,
            'sqli': VulnCategory.SQL_INJECTION,
            'rce': VulnCategory.RCE,
            'lfi': VulnCategory.LFI_RFI,
            'rfi': VulnCategory.LFI_RFI,
            'ssrf': VulnCategory.SSRF,
            'xxe': VulnCategory.XXE,
            'csrf': VulnCategory.CSRF,
            'auth': VulnCategory.AUTHENTICATION,
            'authz': VulnCategory.AUTHORIZATION,
            'info-disclosure': VulnCategory.INFORMATION_DISCLOSURE,
            'misconfig': VulnCategory.MISCONFIG,
            'ssl': VulnCategory.SSL_TLS,
            'tls': VulnCategory.SSL_TLS,
            'dns': VulnCategory.DNS,
            'takeover': VulnCategory.SUBDOMAIN_TAKEOVER
        }
        
        for tag in tags:
            tag_lower = tag.lower()
            if tag_lower in tag_mappings:
                return tag_mappings[tag_lower]
        
        return VulnCategory.GENERIC
    
    def _scan_subdomain_takeover(self, config: ScanConfig) -> List[VulnerabilityResult]:
        """Subdomain takeover scanner using subzy"""
        if not self.available_tools.get('subzy', False):
            return []
        
        vulnerabilities = []
        
        try:
            # Extract domains from targets
            domains = []
            for target in config.targets:
                if target.startswith(('http://', 'https://')):
                    parsed = urlparse(target)
                    domains.append(parsed.netloc)
                else:
                    domains.append(target)
            
            # Create target file
            target_file = Path(f"/tmp/subzy_targets_{config.scan_id}.txt")
            with open(target_file, 'w') as f:
                for domain in domains:
                    f.write(f"{domain}\n")
            
            # Run subzy
            cmd = ['subzy', 'run', '--targets', str(target_file), '--concurrency', '10']
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            if result.returncode == 0:
                # Parse subzy output for vulnerabilities
                for line in result.stdout.split('\n'):
                    if 'VULNERABLE' in line and 'Takeover' in line:
                        parts = line.split()
                        if len(parts) >= 2:
                            vulnerable_domain = parts[1]
                            
                            vuln = VulnerabilityResult(
                                target=vulnerable_domain,
                                vulnerability_id='subdomain-takeover',
                                name='Subdomain Takeover Vulnerability',
                                description=f'Subdomain {vulnerable_domain} is vulnerable to takeover',
                                severity=SeverityLevel.HIGH,
                                category=VulnCategory.SUBDOMAIN_TAKEOVER,
                                source='subzy',
                                verified=True
                            )
                            
                            vulnerabilities.append(vuln)
            
            # Cleanup
            if target_file.exists():
                target_file.unlink()
        
        except Exception as e:
            self.logger.log_error(f"Subdomain takeover scanning failed: {str(e)}", e)
        
        return vulnerabilities
    
    def _scan_ssl_tls(self, config: ScanConfig) -> List[VulnerabilityResult]:
        """SSL/TLS security scanner"""
        vulnerabilities = []
        
        # This would implement SSL/TLS testing
        # For now, placeholder implementation
        
        return vulnerabilities
    
    def _scan_dns_security(self, config: ScanConfig) -> List[VulnerabilityResult]:
        """DNS security scanner"""
        vulnerabilities = []
        
        # This would implement DNS security testing
        # For now, placeholder implementation
        
        return vulnerabilities
    
    def _scan_security_headers(self, config: ScanConfig) -> List[VulnerabilityResult]:
        """Security headers scanner using httpx"""
        vulnerabilities = []
        
        if not self.available_tools.get('httpx', False):
            return vulnerabilities
        
        try:
            # Test targets for missing security headers
            for target in config.targets:
                if not target.startswith(('http://', 'https://')):
                    target = f"https://{target}"
                
                cmd = ['httpx', '-u', target, '-silent', '-json', '-include-response-header']
                
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
                
                if result.returncode == 0:
                    try:
                        data = json.loads(result.stdout)
                        headers = data.get('header', {})
                        
                        # Check for missing security headers
                        security_headers = {
                            'x-frame-options': 'X-Frame-Options header missing',
                            'x-content-type-options': 'X-Content-Type-Options header missing',
                            'x-xss-protection': 'X-XSS-Protection header missing',
                            'strict-transport-security': 'HSTS header missing',
                            'content-security-policy': 'CSP header missing'
                        }
                        
                        for header, description in security_headers.items():
                            if header not in [h.lower() for h in headers.keys()]:
                                vuln = VulnerabilityResult(
                                    target=target,
                                    vulnerability_id=f'missing-{header}',
                                    name=f'Missing {header.title()} Header',
                                    description=description,
                                    severity=SeverityLevel.LOW,
                                    category=VulnCategory.MISCONFIG,
                                    source='header_scanner',
                                    verified=True
                                )
                                vulnerabilities.append(vuln)
                    
                    except json.JSONDecodeError:
                        continue
        
        except Exception as e:
            self.logger.log_error(f"Security headers scanning failed: {str(e)}", e)
        
        return vulnerabilities
    
    # Placeholder implementations for other scanners
    def _scan_directory_traversal(self, config: ScanConfig) -> List[VulnerabilityResult]:
        return []
    
    def _scan_custom_xss(self, config: ScanConfig) -> List[VulnerabilityResult]:
        return []
    
    def _scan_custom_sqli(self, config: ScanConfig) -> List[VulnerabilityResult]:
        return []
    
    def _scan_custom_rce(self, config: ScanConfig) -> List[VulnerabilityResult]:
        return []
    
    def _scan_misconfigurations(self, config: ScanConfig) -> List[VulnerabilityResult]:
        return []


# Factory functions
def create_vulnerability_scanner(logger: ReconForgeLogger, database: ReconForgeDatabase,
                               utils: ReconForgeUtils, display: ReconForgeDisplay) -> VulnerabilityScanner:
    """Create a vulnerability scanner instance"""
    return VulnerabilityScanner(logger, database, utils, display)


def create_scan_config(targets: List[str], scan_id: str, **kwargs) -> ScanConfig:
    """Create a scan configuration with defaults"""
    return ScanConfig(targets=targets, scan_id=scan_id, **kwargs)